#!/work/kate/bin/perl -w
#
# Tool for creating a ROMS landmask from a coastline file.
# For now, we want to work in the longitude range 0 <= lon < 360.

use strict;
use PDL;
use PDL::NetCDF;

#my $grid_file = ">tiny.nc";
my $grid_file = ">PWS_grid_2.nc";
my $coast_file = $ENV{'XCOASTDATA'};

# Read the lat, lon values
my $ncobj = PDL::NetCDF->new($grid_file);
my $grid_lat = $ncobj->get('lat_rho');
my $grid_lon = $ncobj->get('lon_rho');
# check longitude range
$grid_lon += 360*($grid_lon < 0);

my $mask_rho = ones($grid_lat);
my $dims = pdl $grid_lat->dims;
my $imax = $dims->at(0);
my $jmax = $dims->at(1);

print "coastline = $coast_file\n";

# Read the coastline, one chunk at a time
my (@latc, @lonc);

my $count;
open (COAST, $coast_file);
while (<COAST>) {
    my ($lat, $lon) = split();
    if ($lat <= 90.) {
	if ($lon < 0) { $lon += 360.; }
	push(@latc, $lat);
	push(@lonc, $lon);
    } else {
# don't want first and last point to be the same
	if ($latc[0] == $latc[$#latc] && $lonc[0] == $lonc[$#lonc]) {
	    $#lonc--;
	    $#latc--;
	}
	my ($i, $j);
	for ($i = 0; $i < $imax; $i++) {
	    for ($j = 0; $j < $jmax; $j++) {
		my $glat = $grid_lat->at($i,$j);
		my $glon = $grid_lon->at($i,$j);
	        my $in = inside($glon, $glat, \@lonc, \@latc);
		if ($in) {
		    my $mask = $mask_rho->slice("$i,$j");
		    $mask .= 0;
		}
	    }
	}
	$#latc = -1;
	$#lonc = -1;
	$count++;
	print "Done with chunk $count\n";
    }
}

$ncobj->put('mask_rho', ['eta_rho', 'xi_rho'], $mask_rho);
my $mask_u = $mask_rho->slice("0:-2,:") * $mask_rho->slice("1:-1,:");
my $mask_v = $mask_rho->slice(":,0:-2") * $mask_rho->slice(":,1:-1");
my $mask_psi = $mask_rho->slice("0:-2,0:-2")
	     * $mask_rho->slice("0:-2,1:-1")
             * $mask_rho->slice("1:-1,0:-2")
	     * $mask_rho->slice("1:-1,1:-1");
$ncobj->put('mask_u', ['eta_u', 'xi_u'], $mask_u);
$ncobj->put('mask_v', ['eta_v', 'xi_v'], $mask_v);
$ncobj->put('mask_psi', ['eta_psi', 'xi_psi'], $mask_psi);

# end of main

sub inside {
    my ($x, $y, $xr, $yr) = @_;
    my @xb = @$xr;
    my @yb = @$yr;
    if ($#xb < 2) { return 0;}

    my $nc = 0;
    my @yc;
    for (my $k=0; $k <= $#xb; $k++) {
	my $kp1 = int($k + 1 - ($k)*int(($k)/$#xb));
	my $kw = $k;
	next if ($xb[$k] == $xb[$kp1]);
        if ($xb[$k] > $xb[$kp1]) {
	    $kw = $kp1;
	}
	my $ke = $k + $kp1 - $kw;
	next if ($x > $xb[$ke]);
	next if ($x < $xb[$ke] and $x <= $xb[$kw]);
	my $slope = ($yb[$ke] - $yb[$kw]) / ($xb[$ke] - $xb[$kw]);
	$yc[$nc] = $yb[$kw] + ($x - $xb[$kw])*$slope;
	$nc++;
    }

# count the number of times that the boundary cut sthe meridian
# through ($x,$y) south of ($x,$y). An odd count indicates the point
# is inside, even indicates outside.

    my $ind = 0;
    if ($nc > 0) {
	for (my $k=0; $k < $nc; $k++) {
	    if ($yc[$k] < $y) { $ind = (1-$ind); }
	}
    }
    $ind;
}
